
# SQL

## Основы SQL

SQL - язык позволяющий осуществлять запрсосы к БД посредством СУБД. В различных СУБД язык SQL может иметь свою специфичную реализацию (свой диалект).

Подмножество языка SQL:

- DDL (Data Definition Language) - язык для создания и модификации структуры БД с помощью операторов CREATE, ALTER, DROP, TRUNCATE, RENAME.

- DML (Data Manipulation Language) - язык для манипуляции данными в БД с помощью операторов SELECT, INSERT, UPDATE, DELETE.
 
- DCL (Data Control Language) - язык для предоставления и отзыва привилегий пользователя БД с помощью операторов GRANT, DENY, REVOKE. 

- TCL (Transaction Control Language) - язык для контроля и управления транзакциями БД с помощью операторов BEGIN TRANSACTION, COMMIT, ROLLBACK. 

## Основы выборки #1

### Базовый синтаксис

Одна из основных функций SQL - это получение выборок данных из СУБД. Для этого в SQL используется оператор SELECT.

Вывод произвольных значений

    SELECT "Hello world";

Вывод всех данных из таблицы

Для вывода всех данных из таблицы используется символ *

    SELECT * 
    FROM {table_name};

Вывод данных из определенных колонок таблицы 

    SELECT {column_name #1}, {column_name #2} 
    FROM {table_name};

Псевдонимы (алиасы)

Используется оператор AS для присвоения сокращенных имен столбцам или таблицам, улучшает читаемость кода.

    SELECT {column_name #1}, {column_name #2} AS {alias_name} 
    FROM {table_name};

### Литералы в SQL #1.1

Литерал - эот указанное явным образом фиксировоанное значение, например, число 12 или строка "SQL".

Основными типами литералов в MySQL являются:

- строковый;
- числовой;
- логический;
- NULL;
- литерал длаты и времемни.


**Строковые литералы** 

Строка - это последовательность символов, заключенных в одинарные ('') или двойные ("") кавычки.
Строки могут содержать специальные последовательноти символов, начинающиеся с '\' (экранирующий символ).
Они нужны для того, чтобы СУБД придала обычным символам (буквам и другим знакам) новое особое  значение.
Например, последовательность '\n' буквально означает 'перево строки'.

    SELECT "Текстовая строка Текстовая строка" AS String;

    String
    Текстовая строка Текстовая строка

    SELECT "Текстовая строка \n Текстовая строка" AS String;

    String
    Текстовая строка
    Текстовая строка

**Числовые литералы**

Включает в себя целые и дробные числа. Разделительный знак для дробного числа — «.» (точка) - 1, 2.9, 0.01

Может иметь только целую, дробную часть или обе сразу - .2, 1.1, 10

Может быть положительным и отрицательным числом (для положительного числа совсем не обязательно указывать знак) - +1, -10, -2.2

Могут быть представлены в экспоненциальном виде - 1e3 (=1000) 1e-3 (=0.001)

Арифметические операторы

Для числовых литералов в SQL есть все привычные нам арифметические операторы:

| Оператор | Описание | Пример |
| ------------- | ------------- | ------------- |
| %, MOD | Деление по модулю | 11 % 5 = 1 |
| * | Умножение | 10 * 16 = 160 |
| + | Сложение | 98 + 2 = 100 |
| - | Вычитание | 50 - 51 = -1 |
| / | Деление | 1 / 2 = 0.5 |
| DIV | Целочисленное деление | 10 DIV 4 = 2 |

Используя эти операторы можно построить любое арифметическое выражение, применяя стандартные правила арифметики.

Для примера:

    SELECT (5 * 2 - 6) / 2 AS Result;

    Result
    2

**Литералы даты и времени**

Значения даты и времени могут быть представлены в формате строки или числа.
Например, если мы хотим указать какую-то дату в запросе, то мы можем это сделать с помощью строки "1970-12-30", "19701230" или же числа 19701230. В обоих случаях эти значения будут интерпретироваться как дата «30 декабря 1970 года».

Ниже приведён пример использования литерала даты:

    SELECT * FROM FamilyMembers WHERE birthday > '1970-12-30';

Кроме самой даты, мы можем также указывать отдельно время или же всё вместе.

| | Описание | Пример |
| ------------- | ------------- | ------------- |
| Дата | Интерпретируется как дата со временем, равным нулю | *YYYY-MM-DD, YYYYMMDD*; Вместо разделителя "-" можно использовать любой знак препинания; Например:'2020- 1-01' = 1 января 2020, 00:00:00 |
| Время | Содержит только время без конкретной даты | *hh:mm:ss, hh:mm, hh, ss*; Разделитель тоже можно опустить; Например: 12:11 = 12:11:00 |
| Дата и время | Дата с возможностью задать конкретное времяСложение | *YYYY-MM-DD hh:mm:ss YYYYMMDDhhmmss*; Например:'20200101183030' = 1 января 2020, 18:30:30 |


**Логические литералы**

Логический литерал - значения TRUE и FALSE, означающие истинность и ошибочность какого-либо утверждения. При интерпретации запроса, MySQL преобразует их в числа: TRUE и FALSE становятся 1 и 0 соответственно.

**NULL**

Значение NULL означает "нет данных", "нет значения". Оно нужно, чтобы отличать визуально пустые значения, такие как строка нулевой длины или "пробел", от того, когда значения вообще нет, даже пустого.

### Применение функций #1.2

При составлении SQL запросов мы можем использовать встроенные функции. Например, если мы хотим вывести строку в верхнем регистре, то для этого мы можем использовать функцию UPPER.

    SELECT UPPER("Hello world") AS upper_string;
    upper_string
    HELLO WORLD

**Что такое встроенная функция?**

Встроенная функция – реализованный в СУБД кусок кода, с помощью которого можно выполнять преобразования строковых, числовых и других данных в запросах.
Каждая функция принимает набор аргументов определённого типа, выполняет заложенные в неё операции и обязательно возвращает один из возможных литералов. Стоит отметить, что функции могут принимать как ноль аргументов, так и несколько.
Например, функция NOW() принимает ноль аргументов и возвращает литерал в формате даты, а LENGTH('sql') принимает один строковый аргумент и возвращает числовой литерал «11».

**Примеры функций**

Функций достаточно много, но основные всегда можно найти с помощью поиска в шапке или же на странице справочника функций.
Вот некоторые из них:

**LOWER**

Возвращает строку, в которой все символы записаны в нижнем регистре

    SELECT LOWER('SQL Academy') AS lower_string;
    lower_string
    sql academy
	
**YEAR**

Возвращает год для указанной даты

    SELECT YEAR("2022-06-16") AS year;
    year
    2022
	
**INSTR**

Осуществляет поиск подстроки в строке, возвращая позицию её первого символа. При этом отсчёт начинается с единицы, а не нуля, как в большинстве языков программирования.
Функция работает путём посимвольного сравнения исходной строки с искомой. Например, в строке sql-academy подстрока academy появляется, начиная с пятого символа.

    SELECT INSTR('sql-academy', 'academy') AS idx;
    idx
    5

**LENGTH**

Возвращает длину указанной строки.

    SELECT LENGTH('sql-academy') AS str_length;
    str_length
    11

**Применение функций над значениями полей таблицы**

Функции можно применять не только над литералами, но и над значениями, взятыми из таблицы. При этом функция выполняет преобразования для каждой строки отдельно.
Например, давайте вернёмся к нашей базе данных и рассмотрим таблицу FamilyMembers: она содержит имя, статус и дату рождения людей.

    CREATE TABLE FamilyMembers (
            member_id INT PRIMARY KEY AUTO_INCREMENT,
            status VARCHAR(100),
            member_name VARCHAR(100),
            birthday DATETIME
        )
    
    CREATE TABLE Payments (
			payment_id INT PRIMARY KEY AUTO_INCREMENT,
			family_member INT,
			good INT,
			amount INT,
			unit_price INT,
			date DATETIME,
			FOREIGN KEY (family_member) REFERENCES FamilyMembers (member_id)
	)

	CREATE TABLE GoodTypes (
		good_types_id INT PRIMARY KEY AUTO_INCREMENT,
		good_types_name VARCHAR(255)
	)

    CREATE TABLE Goods (
		good_id INT PRIMARY KEY AUTO_INCREMENT,
		good_name VARCHAR(100),
		type INT,
		FOREIGN KEY (type) REFERENCES GoodTypes (good_types_id)
	)

Каждое значение этих полей мы можем изменить при выводе. Так нижележащий запрос высчитывает длину полного имени для каждого из членов семьи.

    SELECT member_name,
        LENGTH(member_name) AS fullname_length
    FROM FamilyMembers;

**Операции над результатом функции**

Поскольку мы знаем, что каждая функция должна вернуть какой-либо из возможных литералов, то её результат также можно использовать в дальнейших расчётах и преобразованиях.
К примеру, мы хотим получить первые три буквы в строке и преобразовать их в заглавные. Для этого нам будет достаточно скомбинировать две функции: LEFT и UPPER, где результат одной функции будет аргументом для второй.

    SELECT UPPER(LEFT('sql-academy', 3)) AS str;
    Str
    SQL

Или хотим вычислить длину фамилии человека, имея строку в формате имя<пробел>фамилия. Одним из возможных способов вычисления длины фамилии может быть применение функций LENGTH и INSTR, используя формулу <длина фамилии> = <длина всей строки> - (<длина имени> + <длина пробела>):
* Значение <длина всей строки> можно получить с помощью функции LENGTH
* Для <длина имени> + <длина пробела> нужно вычислить позицию символа, где заканчивается имя, и прибавить единицу, т.к. пробел имеет длину «1». Мы можем сделать это используя лишь функцию INSTR, ориентируясь на символ «пробел»
Так как обе функции возвращают числовые литералы, мы можем выполнять арифметические операции над ними. Давайте вычтем одно из другого и получим длину фамилии (lastname_length):

    SELECT member_name,
        LENGTH(member_name) AS full_length,
        INSTR(member_name, ' ') AS firstname_with_space_length,
        LENGTH(member_name) - INSTR(member_name, ' ') AS lastname_length
    FROM FamilyMembers;

### Исключение дубликатов, DISTINCT #1.3

В некоторых ситуациях SQL запрос на выборку может возвращать повторяющиеся строки данных.
Например, давайте выведем поле class из таблицы Student_in_class из базы данных, в которой организовано хранение информации о расписании занятий в школе.

    CREATE TABLE Student_in_class (
            id INT AUTO_INCREMENT,
            class INT,
    )

    SELECT class FROM Student_in_class;

Поскольку в одном классе возможно нахождение нескольких студентов, то не удивительно, что при выводе мы можем наблюдать одинаковые значения. Чтобы при выборке избежать такого дублирования, есть оператор DISTINCT.

**Синтаксис оператора**

SELECT [DISTINCT] {column_name} FROM {table_name};
То есть в нашем случае запрос на получение уникальных классов, в которых есть хотя бы один студент, будет выглядеть следующим образом:

    SELECT DISTINCT class FROM Student_in_class;
    DISTINCT для нескольких колонок

При использовании оператора DISTINCT для двух и более колонок будут удаляться записи, которые имеют одинаковые значения по всем полям.

## Условный оператор WHERE #2

Ситуация, когда требуется сделать выборку по определённому условию, встречается очень часто. Для этого в операторе SELECT существует оператор WHERE, после которого следуют условия для ограничения строк. Если запись удовлетворяет этому условию, то попадает в результат, иначе отбрасывается.
Общая структура запроса с оператором WHERE

    SELECT [DISTINCT] {column_name} FROM {table_name}
    WHERE условие_на_ограничение_строк
    
    [логический_оператор другое_условие_на_ограничение_строк];

Например, запрос с использованием оператора WHERE может выглядеть следующим образом:

    SELECT * FROM Student
    WHERE first_name = "Grigorij" AND YEAR(birthday) > 2000;

**Операторы сравнения**

Операторы сравнения служат для сравнения 2 выражений, результатом которого может являться:
* true (что эквивалентно 1)
* false (что эквивалентно 0)
* NULL

| Оператор | Обозначение | Описание |
| ------------- | ------------- | ------------- |
| Равенство | = | Если оба значения равны, то результат будет равен 1, иначе 0 |
| Эквивалентность | <=> | Аналогичен оператору равенства, за исключением того, что результат будет равен 1 в случае сравнения NULL с NULL и 0, когда идёт сравнение любого значения с NULL |
| Неравенство | <> или != | Если оба значения не равны, то результат будет равен 1, иначе 0 |
| Меньше | < | Если одно значение меньше другого, то результат будет равен 1, иначе 0 |
| Меньше или равно | <= | Если одно значение меньше или равно другому, то результат будет равен 1, иначе 0 |
| Больше | > | Если одно значение больше другого, то результат будет равен 1, иначе 0 |
| Больше или равно | >= | Если одно значение больше или равно другому, то результат будет равен 1, иначе 0 |

Результатом сравнения любого значения с NULL является NULL. Исключением является оператор эквивалентности.

    SELECT
        2 = 1,
        'a' = 'a',
        NULL <=> NULL,
        2 <> 2,
        3 < 4,
        10 <= 10,
        7 > 1,
        8 >= 10;

**Логические операторы**

Логические операторы необходимы для связывания операторов сравнения.

| Оператор | Описание |
| ------------- | ------------- |
| NOT | Меняет значение оператора сравнения на противоположный |
| OR | Возвращает общее значение выражения истинно, если хотя бы одно из них истинно |
| AND | Возвращает общее значение выражения истинно, если они оба истинны |
| XOR | Возвращает общее значение выражения истинно, если один и только один аргумент является истинным |

Пример:

    SELECT * FROM Trip
    WHERE plane = 'Boeing' AND NOT town_from = 'London';




